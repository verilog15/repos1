<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="fr">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="created" content="2020-01-10T06:18:10.521000000">
    <meta name="changed" content="2020-01-20T07:26:01.212000000">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="Content-Language" content="fr">
    <title>
      v3.0 hex byte plain
    </title>
    <link rel="stylesheet" type="text/css" href="../../style.css">
  </head>
  <body>
    <h1>
      v3.0 hex byte plain big-endian
    </h1>
    <div class="maindiv">
      <p>
        Ce fichier est structuré comme dans les versions précédentes, la première ligne indique le type de structure et ensuite les lignes suivantes représentent la suite des bits de la mémoire. Ils sont en ASCII avec seulement des symboles hexadécimaux (deux digits) sans la balise 0x.
      </p>
      <blockquote>
        <pre>v3.0 hex bytes plain big-endian
3f45a8c96ea00042f261613443f8b2cb
50950e0604427da5a9641e91526c7970
a7eb2d655343913e6b7d39db17730c77
058ea8ae931cbe211d218d412c76a495</pre>
      </blockquote>
      <p>
        Les retours de ligne de son pas interprété. A l'exception de la première ligne, il n'y a pas de règles de mise en page. Les espaces sont ignorés.
      </p>
      <p>
        Vous pouvez placer des commentaires dans le fichier en utilisant le symbole '#'. Tous les caractères dans la ligne à partir du symbole '#' seront ignorés.
      </p>
      <p>
        Il n'est pas nécessaire de préciser le préfix 0x avant les données, cependant s'ils existent ils seront simplement ignorés.
      </p>
      <p>
        Si longueur de l'ensemble des données du fichier est plus courte que l'espace mémoire les cellules restantes seront initialisées à 0 pour les ROM et pour les RAM à 0 ou aléatoirement selon les paramètres dans <a href="../opts/index.html">Les options de projet</a>.
      </p>
	   <p align="center">
        <img  src="../../../../img-guide/membyteplainbe.png" alt="#########" height=348 width=480>
      </p>
      <p>
        Dans le mode big-endian la mémoire est considérée comme une suite d'octet indépendamment de la dimension de ses mots, avec de gauche à droite les bytes de poids fort puis les bytes de poids faible. Dans la figure ci-dessus, les signes hexadécimaux sont représentés dans leur valeur binaire dans la zone bleu/vert et on peut observer que les octets du fichier (en haut) sont recopiés dans la mémoire en séquence avec des exemples pour des mémoires avec des mots de 4bits,7bits et 12bits. Observez le décalage d'alignement pour les mots non multiples de 8 par exemple dans la mémoire de mot de 7 bits.
      </p>
      <p>
	      <h1 id='little'>
      v3.0 hex byte plain little-endian
    </h1>
    <div class="maindiv">
      <p>
       Ce format suit les mêmes règles que dans les formats précédents. A la différence qu'il est lut dans le mode little-endian, de la droite vers la gauche.
      </p>
      <blockquote>
        <pre>v3.0 hex bytes plain little-endian
3f45a8c96ea00042f261613443f8b2cb
50950e0604427da5a9641e91526c7970
a7eb2d655343913e6b7d39db17730c77
058ea8ae931cbe211d218d412c76a495</pre>
      </blockquote>
      <p align="center">nter>
        <img  src="../../../../img-guide/membyteplainle.png" alt="#########" height=348 width=480>
      </p>
      <p>
        Dans le mode little-endian la mémoire est considérée comme une suite d'octet avec de droite à gauche les bits de poids faible puis les bits de poids fort. Dans la figure ci-dessus on peut observer que les octets du fichier (en haut) sont recopiés dans la mémoire en séquence avec des exemples pour des mémoires avec des mots de 4bits,7bits et 12bits. Vous pouvez observer le décalage d'alignement par exemple pour la mémoire de mot de 7 bits.
		<p align="center">
        <img  class="notscal" src="../../../../img-guide/memelitle.png" alt="#########">
        </p>
		Ces mêmes exemples affichés dans le composant.
      </p>
      <h1 id='addr'>
        v3.0 hex bytes addressed big-endian
      </h1>
      <p>
        Ce format est identique aux précédents avec la possibilité de préciser l'adresse du mot mémoire ou commencer l'enregistrement des données de la ligne.<br>
		Celle-ci est en hexadécimal suivi du caractère <b>:</b>
      </p>
      <blockquote>
        <pre>v3.0 hex bytes addressed big-endian
00: 3f45a8c96ea75086cce5d39d87456709
20: 56788888882efff0ec45670900000000
30: 9863fec8a2d75d342e1f008090445578</pre>
      </blockquote>
      <p>
        Dans cet exemple les 8 mots a l'adresse 0x10 ne sont pas précisés. Ces cellules seront initialisées à 0 et pour les RAM selon les paramètres dans <a href="../opts/index.html">Les options de projet</a>, à 0 ou aléatoirement.
      </p>
      <p align="center">
        <img class="notscal" src="../../../../img-guide/membytepleinadrbig.png" alt="#########">
      </p>
      <h1 id='addr'>
        v3.0 hex bytes addressed little-endian
      </h1>
      <p>
        Ce format est identique aux précédents avec la possibilité de préciser l'adresse du mot mémoire ou commencer l'enregistrement des données de la ligne. 
      </p>
      <blockquote>
        <pre>v3.0 hex bytes addressed little-endian
00: 3f45a8c96ea75086cce5d39d87456709
20: 56788888882efff0ec45670900000000
30: 9863fec8a2d75d342e1f008090445578</pre>
      </blockquote>
      <p>
        <b>Suite:</b> <a href="mem-menu.html">Le menu contextuel et les fichiers</a>.
      </p>
    </div>
  </body>
</html>
