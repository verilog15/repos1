#
# bus/SocBusAttributes.java
#
SocBusTraceSize = 总线位宽：
SocBusTraceVisible = 可见性：
#
# bus/SocBusMenuProvider.java
#
insertTrans = 插入总线事务
SocBusMemMap = 显示内存映射
SocBusTraceWindow = 显示总线事务跟踪
SocInsertTransWindowTitle = 将事务插入总线：
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = 总线跟踪窗口（双击跟踪可将其删除）
#
# data/SocBusInfo.java
#
SocBusNotConnected = 未连接到总线
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = 没有任何痕迹
SocMemMapWindowTitle = 总线内存映射：
SocMemoryMapOk = 关闭
SocMemoryMapTitle = 内存映射（红色表示重叠的内存区域）：
#
# data/SocBusTransaction.java
#
SocBusStateMaster = 启动器：
SocBusStateNoDataMax10chars = 无数据
SocBusStateSlave = 应答者：
SocBusStateTraceIndex = 交易编号：
SocTransactionByteAccesNoSupport = 从机不支持字节访问。
SocTransactionByteAccesNoSupportShort = 无字节访问
SocTransactionHalfWordAccesNoSupport = 从机不支持半字访问。
SocTransactionHalfWordAccesNoSupportShort = 无硬件访问
SocTransactionMisalignedAddress = 从设备检测到地址未对齐。
SocTransactionMisalignedAddressShort = 米萨尔。地址。
SocTransactionMultipleSlaveAnswers = 多个从属服务器响应一个事务。请检查一下您的奴隶的内存映射。
SocTransactionMultipleSlaveAnswersShort = 多个奴隶
SocTransactionNoBusConnected = 主部件没有连接到任何 SoC 总线。请将主机连接到总线组件。
SocTransactionNoBusConnectedShort = 没有公交车
SocTransactionNoneAtomicRW = 请求非原子读/写操作。这是不允许的。
SocTransactionNoneAtomicRWShort = 无原子 RW
SocTransactionNoRespons = 没有从属组件响应该请求。请检查请求的内存地址和系统的内存映射。
SocTransactionNoResponsShort = 无响应
SocTransactionNoSlavesAttached = 连接到主机的总线没有连接从机。请把一些奴隶绑在公共汽车上。
SocTransactionNoSlavesAttachedShort = 没有从机
SocTransactionReadOnlyAccessError = 从机仅支持对此地址的读取访问
SocTransactionReadOnlyAccessErrorShort = 只读
SocTransactionRegisterDoesNotExist = 从设备不支持对此地址的任何访问
SocTransactionRegisterDoesNotExistShort = 禁止访问
SocTransactionSuccessfull = 未发生错误，交易成功。
SocTransactionSuccessfullShort = 成功
SocTransactionUnknownError = 奇怪的是，此错误消息永远不会出现，它代表 Logisim 中的错误。
SocTransactionUnknownErrorShort = Bug！
SocTransactionWordAccesNoSupport = Slave 不支持字访问。
SocTransactionWordAccesNoSupportShort = 无法访问 Word
SocTransactionWriteOnlyAccessError = 从机不支持对此地址执行读取操作。
SocTransactionWriteOnlyAccessErrorShort = 只写
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = 空（没有从机）
SocMemMapEndAddress = 结束地址：
SocMemMapSlaveName = 组件名称：
SocMemMapStartAddress = 起始地址：
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = 请选择要连接的总线
SocBusSelectAttr = 连接的总线
SocBusSelectAttrClick = 单击以选择
SocManagerNoBusses = 没有可用的总线，请将 SoC 总线添加到您的逻辑示意图
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = 已成功将 ELF 文件加载到内存中。\n已将可执行文件的入口点设置为处理器。\n\n重要信息：\n由于 ELF 文件没有关于异常向量的信息，\n您必须自己控制它们！
SocUpMenuAsmWindow = 开放式汇编程序
SocUpMenuCpuAsmWindowTitle = CPU 汇编器：
SocUpMenuCpuProgramWindowTitle = CPU 反汇编程序：
SocUpMenuCpuStateWindowTitle = CPU 的处理器状态：
SocUpMenuErrorReadingElfTitle = 读取 ELF 文件时出错
SocUpMenuReadElf = 读取 ELF 文件
SocUpMenuSelectElfFile = 选择要导入的 ELF 文件
SocUpMenuShowProgram = 显示加载的程序
SocUpMenuShowState = 显示 CPU 状态
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = 已停止
SocUpSimHaltBreak = 断点
SocUpSimHaltError = 错误
SocUpSimRunning = 正在运行
SocUpSimStateLabel = 模拟状态：
SocUpSimstateStart = 开始
SocUpSimstateStop = 暂停
SocUpUnknown = 未知
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = 不是 32 位或 64 位 ELF 文件
ElfHeaderEIDataError = 不是小端或大端的编码文件
ElfHeaderIncorrectEISize = EI 部分的大小不正确
ElfHeaderIncorrectESize = E 部分的大小不正确
ElfHeaderIncorrectMagic = 该文件不包含正确的精灵魔法；可能不是精灵文件
ElfHeaderNoErrors = 标题正确
ElfHeaderReadingFileError = 读取文件时出错
ElfHeaderUnknownArchitecture = 未知架构
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = 找不到程序头。
ProgHeaderReadError = 读取程序标题时出错。
ProgHeaderSizeError = 程序头中的大小不匹配。
ProgHeaderSuccess = 成功
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = 找到多个字符串表，暂时不支持。
ElfSectHeadMultiSymtabError = 发现多个符号表，暂时不支持；
ElfSectHeadNotFound = 找不到节标题。
ElfSectHeadReadError = 读取节标题时出错。
ElfSectHeadSizeError = 节标题中的大小不匹配。
ElfSectHeadStingIdxError = 错误字符串索引。
ElfSectHeadStingNotFound = 找不到节名。
ElfSectHeadStingReadError = 读取字符串表时出错。
ElfSectHeadStingTypeError = 字符串类型错误。
ElfSectHeadSuccess = 成功
ElfSymTableNotFound = 找不到符号表。
ElfSymTableReadError = 无法读取符号表。
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim 尚不支持 64 位 ELF 文件。
ProcReadElfArchError = ELF 文件用于\“%s\”处理器，而它应该用于\“%s\”处理器。
ProcReadElfEndianMismatch = 字节顺序不匹配，ELF 文件是\“%s\”，而处理器请求的是\“%s\”。
ProcReadElfErrorOpeningFile = 无法打开精灵文件
ProcReadElfLoadableSectionNotFound = 在 ELF 文件中找不到可加载节。
ProcReadElfLoadableSectionReadError = 读取可加载节时出错。
ProcReadElfLoadableSectionSizeError = 可加载段中的大小不匹配。
ProcReadElfLoadableSectionTooBig = Logisim 支持的大小越大，可加载段的大小越大。
ProcReadElfMemoryError = 将可加载节写入内存时出错。\n请确保您有可用于内存区域的 SoC 内存组件：\n%s...%s
ProcReadElfNotExecutable = ELF 文件不是可执行文件
ProcReadElfSuccess = 成功
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = 部件文件（.asm、.S）
AsmPanAssemble = 汇编代码（Alt-A）
AsmPanDocumentChangedSave = 您的文档中有更改，是否保存？
AsmPanErrorCreateFile = 无法创建程序集文件。
AsmPanErrorReadingFile = 无法读取该文件
AsmPanNextError = 跳至下一个错误（CTRL-N）
AsmPanOpenFile = 读取文件（CTRL-L）
AsmPanPreviousError = 跳到上一个错误（CTRL-P）
AsmPanReadAsmFile = 选择要读取的文件
AsmPanRun = 运行代码（Alt-R）
AsmPanSaveAsmFile = 选择要保存的文件
AsmPanSaveFile = 保存文件（CTRL-S）
AsmPanSaveFileAs = 将文件另存为
AsmPanSaveFirstBeforeOpen = 您的文档中有更改\n是否要在打开新文件之前保存这些更改？
AssemblerAssembleSuccess = 成功！\n在您的代码中没有发现错误。
AssemblerRunSuccess = 已成功将程序加载到内存。\n若要运行该程序，请确保：\n-启用滴答\n-将 CPU 设置为运行模式。
AssemblerUnableToDownload = 无法将程序存储到内存，\n请确保正确的内存位置\n有足够的内存可用。
RV32imAsmLineIndicator = 第 %d 行，共 %d 行
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = 删除断点
RV32imSetBreakpoint = 添加断点
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = 总线地址：0x
SocTransInsAtomicRequest = 原子事务
SocTransInsByteAccess = 字节事务
SocTransInsHalfWordAccess = 半字事务（2 字节）
SocTransInsInputData = 要写入的数据：0x
SocTransInsInsertTransaction = 将事务插入总线
SocTransInsManual = 手动插入
SocTransInsReadData = 返回的数据：
SocTransInsReadRequest = 总线读取请求
SocTransInsTransResultTitle = 插入的事务的结果：
SocTransInsWordAccess = 字处理（4 字节）
SocTransInsWriteRequest = 总线写入请求
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = 组件：
Rv32imBinInstruction = 操作码：
Rv32imEmptyTrace = 没有可用的执行跟踪
Rv32imExecutionTrace = 执行跟踪（上次在顶部执行）：
Rv32imRegisterFile = 寄存器文件：
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = 仿真控制
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = 清除键盘
JtagUartKeybAvailable = 可用的键盘数据
JtagUartKeybData = 键盘数据
JtagUartKeybReadEnable = 键盘读取启用
JtagUartTtyClear = TTY 清除
JtagUartTtyData = TTY 数据
JtagUartTtyWrite = TTY 写入数据
SocJtagUartComponent = JTAG UART
#
# jtaguart/JtagUartAttributes.java
#
JtagUartReadIrqThreshold = 读取 IRQ 阈值
JtagUartWriteIrqThreshold = 写入 IRQ 阈值
UartJtagREADFifoSize = 读取 FIFO 大小：
UartJtagWriteFifoSize = 写入 FIFO 大小：
#
# memory/SocMemory.java
#
SocMemBase = 底座：
SocMemoryComponent = 存储器模拟器
SocMemSizeStr = 大小：
#
# memory/SocMemoryAttributes.java
#
SocMemSize = 字节地址宽度：
SocMemStartAddress = 起始地址：
#
# nios2/Nios2.java
#
Nios2A = 一个
Nios2B = B 类
Nios2C = C
Nios2Component = Nios2S 模拟器
Nios2Dataa = 数据 A
Nios2Datab = 数据 B
Nios2Done = 完成
Nios2N = n
Nios2ReadRa = 读取范围
Nios2ReadRb = 读取 RB
Nios2Result = 结果
Nios2Start = 开始
Nios2WriteRc = 写入 RC
Rv32imClockInput = 时钟输入
Rv32imIrqInput = IRQ 输入 %s
Rv32imResetInput = 重置输入
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = 中断向量
rv32ExceptionVector = 异常向量
rv32imIrqWidth = IRQ 线路数
rv32ResetVector = 重置向量
rv32StateVisible = 状态可见：
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = 需要四个参数
Nios2DonePinError = 未定义完成引脚或处于错误状态，无法继续。\n请检查完成引脚。
Nios2DonePinError = 未定义完成引脚或处于错误状态，无法继续。\n请检查完成引脚。
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = 执行从内存系统加载时出错：
LoadStoreErrorInWriteTransaction = 执行存储到内存系统时出错：
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = 需要立即值
AssemblerExpectedNoArguments = 不需要任何参数
AssemblerExpectedOneArgument = 需要一个参数
AssemblerExpectedTwoArguments = 需要两个参数
AssemblerExpectedZeroOrOneArgument = 应为无参数或只有一个参数
AssemblerImmediateOutOfRange = 立即值超出范围
AssemblerUnknownRegister = 未知寄存器
Nios2AssemblerExpectedBracketedRegister = 需要带括号的寄存器，例如（R1）
Nios2AssemblerExpectedImmediateIndexedRegister = 应为立即索引寄存器，例如 5（R1）
Nios2CannotUseControlRegister = 无法在此上下文中使用控制寄存器
Nios2CannotUseCustomRegister = 无法在此上下文中使用自定义寄存器
Nios2ExpectedControlRegister = 需要控制寄存器（例如 CTL4）
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = 需要三个参数
AssemblerExpextedImmediateOrLabel = 应为立即值或标签
#
# nios2/Nios2State.java
#
Nios2Bstatus = B 状态
Nios2Estatus = E 状态
Nios2Status = 状态
RV32imBreakPointReached = 由于在当前指令处设置了断点，因此暂停执行。
RV32imFetchExecutionError = 执行取数指令时出错
RV32imFetchInvalidInstruction = 获取的指令无效
RV32imFetchInvInstrAsm = 无效指令！
RV32imFetchTransaction = ->获取交易错误。
Rv32imProgramCounter = PC：
SocHiddenForFasterSimulation = 隐藏内容以加快模拟速度
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = 需要寄存器
#
# pio/PioAttributes.java
#
SicPioIrqType = IRQ 类型：
SocPioAnyEdge = 任何边
SocPioBidir = 双向（三态）端口
SocPioCaptureEdge = 捕获类型：
SocPioDirection = 方向：
SocPioFallingEdge = 下降沿
SocPioGenIRQ = IRQ 已启用：
SocPioInout = 输入和输出端口都有
SocPioInputCaptureBit = 捕获位清除：
SocPioInputOnly = 仅限输入端口
SocPioInputsSyncCapture = 同步捕获：
SocPioIrQEdge = 边缘
SocPioIrqLevel = 级别
SocPioOutputIndividualBits = 输出位设置/清除：
SocPioOutputOnly = 仅限输出端口
SocPioOutputResetValue = 输出复位值：
SocPioRisingEdge = 上升沿
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = 无法创建头文件和/或 C 文件！
ExportC = 导出 C 模板
PioMenuBidirFunctionsRemark = /*使用以下功能可以设置或读取双向寄存器。\n*1 表示尊重。位是输出，0 表示它是输入\n*注意：只使用较低的 %s 位。\n*/
PioMenuCaptureAll = 独立于参数“VALUE”的值清除捕获寄存器中的所有位
PioMenuCaptureAny = 至少从 0 更改为 1 或从 1 更改为 0
PioMenuCaptureBit = 清除捕获寄存器中参数“VALUE”中为 1 的位
PioMenuCaptureFalling = 至少一个从 1 到 0 的更改
PioMenuCaptureRising = 至少一个从 0 到 1 的更改
PioMenuEdgeCaptureRemark = /*使用以下功能可以清除或读出边沿捕获寄存器\n*如果读出边沿寄存器，\n*如果读出边沿寄存器，则相应的输入\n*具有 HAT%s，\n*否则相应的输入没有更改。\n*\n*写入此寄存器将为 %s。\n*注意：仅使用较低的 %s 位。\n*/
PioMenuInputDataFunctionRemark = /*使用以下函数可以\n*读出 PIO 的输入值。\n*此函数返回各自的值\n*注意：只有较低的 %s 位有效\n*/
PioMenuIrqEdge = 捕获寄存器中的相应位
PioMenuIrqLevel = 相应的输入
PioMenuMaskFunctionsRemark = /*使用以下函数可以设置或读出中断屏蔽寄存器。\n*特定位置上的 1 表示如果 %s 等于 1，\n*将生成中断。\n*注意：仅使用较低的 %s 位。\n*/
PioMenuOutClearRemark = /*使用以下函数，参数“value”中为 1 的位将强制\n*相应的输出为 0\n*注意：仅使用较低的 %s 位。\n*/
PioMenuOutputDataFunctionRemark = /*使用以下函数可以设置\n*PIO 的输出值。\n*此函数将新的输出值作为参数“value”\n*注意：只有提供的参数“value”的低 %s 位才有效\n*/
PioMenuOutSetRemark = /*使用以下函数，参数“value”中为 1 的位将强制\n*相应的输出为 1\n*注意：仅使用较低的 %s 位。\n*/
SelectDirectoryToStoreC = 设置存储 C 模板的目录
SuccesCreatingHeaderAndCFile = 已成功创建文件：\n%s\n和\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx = 双目录位 %s
SocPioBidirs = 双向销
SocPioComponent = 并行输入/输出扩展器
SocPioInputPinx = 输入位 %s
SocPioInputs = 输入引脚
SocPioIrqOutput = IRQ 输出
SocPioOutputPinx = 输出位 %s
SocPioOutputs = 输出引脚
SocPioResetInput = 重置输入
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = RISC-V IM 模拟器
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = 需要一个或两个参数
Rv32imAssemblerExpectedTwoOrThreeArguments = 需要两个或三个参数
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = 目前未实现环境调用和断点
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = Bug！
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = 需要带括号的寄存器，例如（X1）
RV32imAssemblerExpectedImmediateIndexedRegister = 需要立即索引寄存器，例如 5（X1）
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = 不支持的 ASM 操作码
Rv32imMOINotImplmented = 目前没有实现存储器排序指令
#
# Soc.java
#
SocBusComponent = SoC 总线模拟器
socLibrary = SOC
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = 未知操作码
UnknownInstruction = 未知指令
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = 假定最低地址以指令为入口点。\n为确保 CPU 在正确的地址开始执行，\n请在 CPU 应开始执行程序的位置\n添加名为‘_start’的标签。
AssemblerCannotUseInsideMacro = 此构造不能在宏定义内使用
AssemblerEndOfMacroNotFound = 找不到宏定义的结尾
AssemblerExpectedMacroName = 需要宏的名称
AssemblerExpectedMacroNrOfParameters = 预期的宏参数数量
AssemblerExpectingLabelIdentifier = 需要标签
AssemblerMissingLabelBefore = 对于此运算符，应该是一个标签
AssemblerNoExecutableSection = 找不到可以执行的指令。
AssemblerReguiresNumberAfterMath = 在数学运算之后应该跟一个数字
AssemblerUnknowCharacter = 未知字符
AssemblerWrongClosingBracket = 不支持此右括号
AssemblerWrongOpeningBracket = 不支持此左方括号
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = 无法确定此标签的地址
AssemblerCouldNotFindValueForDefine = 找不到此参数的定义
AssemblerDivZero = 除以零误差
AssemblerExpectedImmediateValueAfterMath = 数学运算后需要立即值
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = 标签名称必须唯一，找到此标签的多个定义
AssemblerDuplicatedName = .eque 和标签不能使用相同的名称
AssemblerDuplicatedSectionError = 节名称必须唯一，找到多个具有此名称的节
AssemblerExpectedLabel = 需要标签
AssemblerExpectedLabelAndNumber = 应为标签后跟立即值
AssemblerExpectedParameter = 此位置需要一个参数
AssemblerExpectingNumber = 需要一个数字
AssemblerExpectingPositiveNumber = 应为正数
AssemblerExpectingSectionName = 需要此节的名称
AssemblerExpectingString = 应为字符串
AssemblerMacroIncorrectNumberOfParameters = 指定的宏参数数目不正确
AssemblerOverlappingSections = 此部分与另一个部分重叠
AssemblerUnknownIdentifier = 我不知道这个标识符
AssemblerUnknownLabel = 此标签尚未定义，因此我无法使用它
AssemblerUnsupportedAssemblerInstruction = 此汇编指令未知
AssemblerValueOutOfRange = 值超出范围
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = 宏相互调用导致死锁情况
AssemblerMacroCannotUseRecurency = 宏正在调用自身，导致死锁情况
AssemblerMacroParameterNotDefined = 未定义此宏参数，请检查宏定义中的参数数量
#
# vga/SocVgaShape.java
#
SocVgaComponent = VGA 屏幕
#
# vga/VgaAttributes.java
#
VgaBufferAddress = 像素缓冲区地址：
VgaInitialDisplayMode = 显示模式：
VgaSoftMode = 软件 %s：
VgaStartAddress = 基址：
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /*使用以下函数可以操作 VGA 模式。\n*读取 VGA 模式将返回支持的模式（请参阅上面对可能模式的定义）\n*写入支持的模式将更改 VGA 显示器的显示模式\n*/
